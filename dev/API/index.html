<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PlantSimEngine.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://VEZY.github.io/PlantSimEngine.jl/API/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PlantSimEngine.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../design/">Design</a></li><li><span class="tocitem">Extending</span><ul><li><a class="tocitem" href="../extending/implement_a_process/">Processes</a></li><li><a class="tocitem" href="../extending/implement_a_model/">Models</a></li></ul></li><li><span class="tocitem">Coupling</span><ul><li><a class="tocitem" href="../model_coupling/model_coupling_user/">Users</a></li><li><a class="tocitem" href="../model_coupling/model_coupling_modeler/">Modelers</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#API-documentation"><span>API documentation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/PlantSimEngine.jl/blob/main/docs/src/API.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:PlantSimEngine.TimeStepTable}"><code>DataFrames.DataFrame</code></a></li><li><a href="#DataFrames.DataFrame-Tuple{T} where T&lt;:PlantSimEngine.ModelList"><code>DataFrames.DataFrame</code></a></li><li><a href="#DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:PlantSimEngine.Status}"><code>DataFrames.DataFrame</code></a></li><li><a href="#DataFrames.DataFrame-Tuple{T} where T&lt;:Union{AbstractArray{&lt;:PlantSimEngine.ModelList}, PlantSimEngine.ModelList}"><code>DataFrames.DataFrame</code></a></li><li><a href="#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a></li><li><a href="#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a></li><li><a href="#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a></li><li><a href="#PlantSimEngine.TimeStepTable"><code>PlantSimEngine.TimeStepTable</code></a></li><li><a href="#Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:PlantSimEngine.ModelList} where N)"><code>Base.copy</code></a></li><li><a href="#Base.copy-Tuple{T} where T&lt;:PlantSimEngine.ModelList"><code>Base.copy</code></a></li><li><a href="#Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:PlantSimEngine.ModelList})"><code>Base.copy</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:PlantSimEngine.ModelList"><code>Base.getindex</code></a></li><li><a href="#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a></li><li><a href="#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a></li><li><a href="#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a></li><li><a href="#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a></li><li><a href="#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}"><code>PlantSimEngine.convert_vars</code></a></li><li><a href="#PlantSimEngine.dep-Tuple{}"><code>PlantSimEngine.dep</code></a></li><li><a href="#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a></li><li><a href="#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a></li><li><a href="#PlantSimEngine.draw_dependency_tree-Tuple{Any, Any}"><code>PlantSimEngine.draw_dependency_tree</code></a></li><li><a href="#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a></li><li><a href="#PlantSimEngine.draw_panel-NTuple{4, Any}"><code>PlantSimEngine.draw_panel</code></a></li><li><a href="#PlantSimEngine.get_attr_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:Nothing"><code>PlantSimEngine.get_attr_i</code></a></li><li><a href="#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="#PlantSimEngine.init_mtg_models!"><code>PlantSimEngine.init_mtg_models!</code></a></li><li><a href="#PlantSimEngine.init_status!-Tuple{Dict{String, PlantSimEngine.ModelList}}"><code>PlantSimEngine.init_status!</code></a></li><li><a href="#PlantSimEngine.init_variables-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.init_variables</code></a></li><li><a href="#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a></li><li><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.inputs</code></a></li><li><a href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:PlantSimEngine.ModelList"><code>PlantSimEngine.is_initialized</code></a></li><li><a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.outputs</code></a></li><li><a href="#PlantSimEngine.pre_allocate_attr!-Tuple{Any, Any}"><code>PlantSimEngine.pre_allocate_attr!</code></a></li><li><a href="#PlantSimEngine.pull_status!-Tuple{Any}"><code>PlantSimEngine.pull_status!</code></a></li><li><a href="#PlantSimEngine.pull_status_one_step!-Tuple{Any, Any}"><code>PlantSimEngine.pull_status_one_step!</code></a></li><li><a href="#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a></li><li><a href="#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.ModelList}"><code>PlantSimEngine.to_initialize</code></a></li><li><a href="#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}"><code>PlantSimEngine.update_mtg_models!</code></a></li><li><a href="#PlantSimEngine.variables-Tuple{}"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, PlantSimEngine.AbstractModel}"><code>PlantSimEngine.variables</code></a></li><li><a href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.variables_typed</code></a></li><li><a href="#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:PlantSimEngine.Status"><code>PlantSimEngine.vars_not_init_</code></a></li><li><a href="#PlantSimEngine.@gen_process_methods"><code>PlantSimEngine.@gen_process_methods</code></a></li></ul><h2 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Tuple{T} where T&lt;:PlantSimEngine.ModelList" href="#DataFrames.DataFrame-Tuple{T} where T&lt;:PlantSimEngine.ModelList"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(components::T) where {T&lt;:ModelList}</code></pre><p>Generic implementation of <code>DataFrame</code> for a single <code>ModelList</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/dataframe.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Tuple{T} where T&lt;:Union{AbstractArray{&lt;:PlantSimEngine.ModelList}, PlantSimEngine.ModelList}" href="#DataFrames.DataFrame-Tuple{T} where T&lt;:Union{AbstractArray{&lt;:PlantSimEngine.ModelList}, PlantSimEngine.ModelList}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(components &lt;: AbstractArray{&lt;:ModelList})
DataFrame(components &lt;: AbstractDict{N,&lt;:ModelList})</code></pre><p>Fetch the data from a <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a> (or an Array/Dict of) status into a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/dataframe.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:PlantSimEngine.Status}" href="#DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:PlantSimEngine.Status}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(components::ModelList{T,S}) where {T,S&lt;:AbstractDict}</code></pre><p>Implementation of <code>DataFrame</code> for a <code>ModelList</code> model with one time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/dataframe.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:PlantSimEngine.TimeStepTable}" href="#DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:PlantSimEngine.TimeStepTable}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(components::ModelList{T,&lt;:TimeStepTable})</code></pre><p>Implementation of <code>DataFrame</code> for a <code>ModelList</code> model with several time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/dataframe.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.AbstractModel" href="#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract model type. All models are subtypes of this one, see <em>e.g.</em> <a href="@ref"><code>AbstractAModel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/Abstract_model_structs.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.ModelList" href="#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelList(models::M, status::S)
ModelList(;
    status=nothing,
    init_fun::Function=init_fun_default,
    type_promotion=nothing,
    variables_check=true,
    kwargs...
)</code></pre><p>List the models for a simulation (<code>models</code>), and does all boilerplate for variable initialization,  type promotion, time steps handling.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The status field depends on the input models. You can get the variables needed by a model using <a href="#PlantSimEngine.variables-Tuple{}"><code>variables</code></a> on the instantiation of a model. You can also use <a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>inputs</code></a> and <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>outputs</code></a> instead.</p></div></div><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `models`: a list of models. Usually given as a `NamedTuple`, but can be any other structure that 
implements `getproperty`.
- `status`: a structure containing the initializations for the variables of the models. Usually a NamedTuple
when given as a kwarg, or any structure that implements the Tables interface from `Tables.jl` (*e.g.* DataFrame).
- `init_fun`: a function that initializes the status based on a vector of NamedTuples (see details).
- `type_promotion`: optional type conversion for the variables with default values.
`nothing` by default, *i.e.* no conversion. Note that conversion is not applied to the
variables input by the user as `kwargs` (need to do it manually).
Should be provided as a Dict with current type as keys and new type as values.
- `variables_check=true`: check that all needed variables are initialized by the user.
- `kwargs`: the models, named after the process they simulate.</code></pre><p><strong>Details</strong></p><p>The argument <code>init_fun</code> is set by default to <code>init_fun_default</code> which initializes the status with a <code>TimeStepTable</code> of <code>Status</code> structures.</p><p>If you change <code>init_fun</code> by another function, make sure the type you are using (<em>i.e.</em> in place of <code>TimeStepTable</code>)  implements the <code>Tables.jl</code> interface (<em>e.g.</em> DataFrame does). And if you still use <code>TimeStepTable</code> but only change <code>Status</code>, make sure the type you give is indexable using the dot synthax (<em>e.g.</em> <code>x.var</code>).</p><p>If you need to input a custom Type for the status and make your users able to only partially initialize  the <code>status</code> field in the input, you&#39;ll have to implement a method for <code>add_model_vars!</code>, a function that  adds the models variables to the type in case it is not fully initialized.</p><p><strong>Examples</strong></p><p>A leaf with a width of 0.03 m, that uses the Monteith and Unsworth (2013) model for energy balance, the Farquhar et al. (1980) model for photosynthesis, and a constant stomatal conductance for CO₂ of 0.0011 with no residual conductance.</p><pre><code class="language- hljs">using PlantBiophysics</code></pre><pre><code class="language- hljs">leaf = ModelList(
    energy_balance = Monteith(),
    photosynthesis = Fvcb(),
    stomatal_conductance = ConstantGs(0.0, 0.0011)
)</code></pre><p>No variables were given as keyword arguments, that means that the status of the leaf is not set yet, and all variables are initialized to <code>typemin(Type)</code>, <em>i.e.</em> <code>-Inf</code> for floating point numbers. This component cannot be simulated yet.</p><p>To know which variables we need to initialize for a simulation, we use <a href="#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.ModelList}"><code>to_initialize</code></a>:</p><pre><code class="language- hljs">to_initialize(leaf)</code></pre><p>The meaning and units of the variables can be found on the documentation of each model, <em>e.g.</em> <a href="https://vezy.github.io/PlantBiophysics.jl/stable/models/photosynthesis/">here for photosynthesis</a>.</p><p>We can now provide values for these variables:</p><pre><code class="language- hljs">leaf = ModelList(
    energy_balance = Monteith(),
    photosynthesis = Fvcb(),
    stomatal_conductance = ConstantGs(0.0, 0.0011),
    status = (Rₛ = 13.747, sky_fraction = 1.0, d = 0.03, PPFD = 1500)
)</code></pre><p>We can now simulate the leaf, <em>e.g.</em> for the energy_balance (coupled to photosynthesis and stomatal conductance):</p><pre><code class="language- hljs">meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)

energy_balance!(leaf,meteo)

DataFrame(leaf)</code></pre><p>If we want to use special types for the variables, we can use the <code>type_promotion</code> argument:</p><pre><code class="language- hljs">leaf = ModelList(
    energy_balance = Monteith(),
    photosynthesis = Fvcb(),
    stomatal_conductance = ConstantGs(0.0, 0.0011),
    status = (Rₛ = 13.747, sky_fraction = 1.0, d = 0.03, PPFD = 1500),
    type_promotion = Dict(Float64 =&gt; Float32)
)</code></pre><p>We can also use DataFrame as the status type:</p><pre><code class="language- hljs">using DataFrames
df = DataFrame(:Rₛ =&gt; [13.747, 13.8], :sky_fraction =&gt; [1.0, 1.0], :d =&gt; [0.03, 0.03], :PPFD =&gt; [1300.0, 1500.0])
m = ModelList(
    energy_balance=Monteith(),
    photosynthesis=Fvcb(),
    stomatal_conductance=Medlyn(0.03, 12.0),
    status=df,
    init_fun=x -&gt; DataFrame(x)
)

# Note that we use `init_fun` to force the status into a `DataFrame`,
# otherwise it would be automatically converted into a `TimeStepTable{Status}`.</code></pre><p>Note that computations will be slower using DataFrame, so if performance is an issue, use TimeStepTable instead (or a NamedTuple as shown in the example).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L2-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.Status" href="#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Status(vars)</code></pre><p>Status type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the <a href="@ref"><code>TimeStepRow</code></a> of a <a href="#PlantSimEngine.TimeStepTable"><code>TimeStepTable</code></a> of a <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a>.</p><p>Most of the code is taken from MasonProtter/MutableNamedTuples.jl, so <code>Status</code> is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a <code>NamedTuple</code> of the references to the values of the variables, which makes it mutable.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A leaf with one value for all variables will make a status with one time step:
st = Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, PPFD=1500.0)

# Indexing a Status with a symbol returns the value of the variable:
st[:Tₗ]

# Indexing the Status with an integer returns the value of the variable by position:
st[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/Status.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.TimeStepTable" href="#PlantSimEngine.TimeStepTable"><code>PlantSimEngine.TimeStepTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeStepTable(vars)
TimeStepTable{Status}(df::DataFrame)</code></pre><p><code>TimeStepTable</code> stores the values of the variables for each time step of a simulation. For example, it is used as the structure in the status field of the <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a> type.</p><p><code>TimeStepTable</code> implements the <code>Tables.jl</code> interface, so it can be used with any package that uses <code>Tables.jl</code> (like <code>DataFrames.jl</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># A leaf with several values for at least one of its variable will automatically use 
# TimeStepTable{Status} with the time steps:
leaf = ModelList(
    photosynthesis = Fvcb(),
    stomatal_conductance = Medlyn(0.03, 12.0),
    status=(Tₗ=[25.0, 26.0], PPFD=1000.0, Cₛ=400.0, Dₗ=1.0)
)

# The status of the leaf is a TimeStepTable:
status(leaf)


# Of course we can also create a TimeStepTable manually:
TimeStepTable(
    [
        Status(Tₗ=25.0, PPFD=1000.0, Cₛ=400.0, Dₗ=1.0),
        Status(Tₗ=26.0, PPFD=1200.0, Cₛ=400.0, Dₗ=1.2),
    ]
)

# We can also create a TimeStepTable from a DataFrame:
using DataFrames
df = DataFrame(
    Tₗ=[25.0, 26.0],
    PPFD=[1000.0, 1200.0],
    Cₛ=[400.0, 400.0],
    Dₗ=[1.0, 1.2],
)
TimeStepTable{Status}(df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/TimeStepTable.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:PlantSimEngine.ModelList})" href="#Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:PlantSimEngine.ModelList})"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractArray{&lt;:ModelList})</code></pre><p>Copy an array-alike of <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:PlantSimEngine.ModelList} where N)" href="#Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:PlantSimEngine.ModelList} where N)"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractDict{N,&lt;:ModelList} where N)</code></pre><p>Copy a Dict-alike <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L274-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{T} where T&lt;:PlantSimEngine.ModelList" href="#Base.copy-Tuple{T} where T&lt;:PlantSimEngine.ModelList"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.copy(l::ModelList)
Base.copy(l::ModelList, status)</code></pre><p>Copy a <a href="#PlantSimEngine.ModelList"><code>ModelList</code></a>, eventually with new values for the status.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L245-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:PlantSimEngine.ModelList" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:PlantSimEngine.ModelList"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(component&lt;:ModelList, key::Symbol)
getindex(component&lt;:ModelList, key)</code></pre><p>Indexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lm = ModelList(
    energy_balance = Monteith(),
    photosynthesis = Fvcb(),
    stomatal_conductance = ConstantGs(0.0, 0.0011),
    status = (Cᵢ = 380.0, Tₗ = [20.0, 25.0])
)

lm[:Tₗ] # Returns the value of the Tₗ variable
lm[2]  # Returns the status at the second time-step
lm[2][:Tₗ] # Returns the value of Tₗ at the second time-step
lm[:Tₗ][2] # Equivalent of the above</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/get_status.jl#L32-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.EF-Tuple{Any, Any}" href="#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EF(obs,sim)

Returns the Efficiency Factor between observations `obs` and simulations `sim` using NSE (Nash-Sutcliffe efficiency) model.
More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe_model_efficiency_coefficient.

The closer to 1 the better.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/evaluation/statistics.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.NRMSE-Tuple{Any, Any}" href="#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NRMSE(obs,sim)

Returns the Normalized Root Mean Squared Error between observations `obs` and simulations `sim`.
Normalization is performed using division by observations range (max-min).

Output: Float/Particles</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/evaluation/statistics.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.RMSE-Tuple{Any, Any}" href="#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RMSE(obs,sim)

Returns the Root Mean Squared Error between observations `obs` and simulations `sim`.

The closer to 0 the better.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/evaluation/statistics.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}" href="#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_model_vars(x)</code></pre><p>Check which variables in <code>x</code> are not initialized considering a set of models and the variables needed for their simulation. If some variables are unitialized, initialize them to their default values.</p><p>This function needs to be implemented for each type of <code>x</code> (please do it if you need it).</p><p>Careful, the function mutates <code>x</code> in place for performance. We don&#39;t put the <code>!</code> in the name just because it also returns it (impossible to mutate when <code>x</code> is nothing)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L168-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}" href="#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}"><code>PlantSimEngine.convert_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_vars(type_promotion::Dict{DataType,DataType}, ref_vars)
convert_vars(type_promotion::Nothing, ref_vars)</code></pre><p>Convert the status variables to the type specified in the type promotion dictionary.</p><p><strong>Examples</strong></p><p>If we want all the variables that are Reals to be Float32, we can use:</p><pre><code class="language-julia hljs">ref_vars = init_variables(energy_balance=Monteith(), photosynthesis=Fvcb(), stomatal_conductance=Medlyn(0.03, 12.0))
type_promotion = Dict(Real =&gt; Float32)

convert_vars(type_promotion, ref_vars)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L284-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.dep-Tuple{}" href="#PlantSimEngine.dep-Tuple{}"><code>PlantSimEngine.dep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dep(models::ModelList; verbose::Bool=true)</code></pre><p>Get the model dependency tree given a ModelList. If one tree is returned, then all models are coupled. If several trees are returned, then only the models inside each tree are coupled, and the models in different trees are not coupled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_dependency.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.diff_vars-Tuple{Any, Any}" href="#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_vars(x, y)</code></pre><p>Returns the names of variables that have different values in x and y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_inputs_outputs.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.dr-Tuple{Any, Any}" href="#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dr(obs,sim)

Returns the Willmott’s refined index of agreement dᵣ.
Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419

The closer to 1 the better.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/evaluation/statistics.jl#L39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.draw_dependency_tree-Tuple{Any, Any}" href="#PlantSimEngine.draw_dependency_tree-Tuple{Any, Any}"><code>PlantSimEngine.draw_dependency_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_dependency_tree(
    tree, node;
    guides_style::String=TERM_THEME[].tree_guide_style,
    dep_tree_guides=(space=&quot; &quot;, vline=&quot;│&quot;, branch=&quot;├&quot;, leaf=&quot;└&quot;, hline=&quot;─&quot;)
)</code></pre><p>Draw the dependency tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_dependency.jl#L151-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.draw_guide-NTuple{5, Any}" href="#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_guide(h, w, prefix, isleaf, guides)</code></pre><p>Draw the line guide for one node of the dependency tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_dependency.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.draw_panel-NTuple{4, Any}" href="#PlantSimEngine.draw_panel-NTuple{4, Any}"><code>PlantSimEngine.draw_panel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_panel(node, tree, prefix, dep_tree_guides)</code></pre><p>Draw the panels for all dependencies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_dependency.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.get_attr_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:Nothing" href="#PlantSimEngine.get_attr_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T&lt;:Nothing"><code>PlantSimEngine.get_attr_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_attr_i(node, attr, i&lt;:Nothing)
get_attr_i(node, attr, i)</code></pre><p>Get node attribute at ith value or only value if <code>i&lt;:Nothing</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/mtg/init_mtg_models.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}" href="#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_ts_kwargs(kwargs)</code></pre><p>By default, the function returns its argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}</code></pre><p>Takes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to <em>e.g.</em> give constant values for all time-steps for one variable.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], PPFD=1000.0))
# [(Tₗ=25.0, PPFD=1000.0), (Tₗ=26.0, PPFD=1000.0)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/ModelList.jl#L209-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_mtg_models!" href="#PlantSimEngine.init_mtg_models!"><code>PlantSimEngine.init_mtg_models!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_mtg_models!(
    mtg::MultiScaleTreeGraph.Node,
    models::Dict{String,&lt;:ModelList},
    i=nothing;
    verbose=true,
    attr_name=:models
)</code></pre><p>initialize the components of an MTG (<em>i.e.</em> nodes) with the corresponding models.</p><p>The function checks if the models associated to each component of the MTG are fully initialized, and if not, tries to initialize the variables using the MTG attributes with the exact same name, and if not found, returns an error.</p><p><strong>Arguments</strong></p><ul><li><code>mtg::MultiScaleTreeGraph.Node</code>: the MTG tree.</li><li><code>models::Dict{String,ModelList}</code>: a dictionary of models named by components names</li><li><code>i=nothing</code>: the time-step to initialize. If <code>nothing</code>, initialize all the time-steps.</li><li><code>verbose = true</code>: return information during the processes</li><li><code>attr_name = :models</code>: the node attribute name used to store the models</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantBiophysics, MultiScaleTreeGraph, PlantGeom

# Read the file
file = joinpath(dirname(dirname(pathof(PlantBiophysics))),&quot;test&quot;,&quot;inputs&quot;,&quot;scene&quot;,&quot;opf&quot;,&quot;coffee.opf&quot;)
mtg = read_opf(file)

# Declare our models:
models = Dict(
    &quot;Leaf&quot; =&gt;
        ModelList(
            energy_balance = Monteith(),
            photosynthesis = Fvcb(),
            stomatal_conductance = Medlyn(0.03, 12.0),
            status = (d = 0.03,)
        )
)

# Checking which variables are needed for our models:
[component =&gt; to_initialize(model) for (component, model) in models]
# OK we need to initialize Rₛ, sky_fraction and the PPFD

# We can compute them directly inside the MTG from available variables:
transform!(
    mtg,
    [:Ra_PAR_f, :Ra_NIR_f] =&gt; ((x, y) -&gt; x + y) =&gt; :Rₛ,
    :Ra_PAR_f =&gt; (x -&gt; x * 4.57) =&gt; :PPFD,
    ignore_nothing = true
)

# Initialising all components with their corresponding models and initialisations:
init_mtg_models!(mtg, models)
# Note that this is possible only because the initialisation values are found in the MTG.
# If the initialisations are constant values between components, we can directly initialize
# them in the models definition (we initialize `:d` like this in our example).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/mtg/init_mtg_models.jl#L1-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_status!-Tuple{Dict{String, PlantSimEngine.ModelList}}" href="#PlantSimEngine.init_status!-Tuple{Dict{String, PlantSimEngine.ModelList}}"><code>PlantSimEngine.init_status!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_status!(object::Dict{String,ModelList};vars...)
init_status!(component::ModelList;vars...)</code></pre><p>Intialise model variables for components with user input.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">model = read_model(&quot;a-model-file.yml&quot;)
init_status!(model, Tₗ = 25.0, PPFD = 1000.0, Cₛ = 400.0, Dₗ = 1.2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/model_initialisation.jl#L75-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_variables-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel" href="#PlantSimEngine.init_variables-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.init_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_variables(models...)</code></pre><p>Intialized model variables with their default values. The variables are taken from the inputs and outputs of the models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">init_variables(Monteith())
init_variables(energy_balance = Monteith(), stomatal_conductance = Medlyn(0.03,12.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/model_initialisation.jl#L113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.init_variables_manual-Tuple{Any, Any}" href="#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_variables_manual(models...;vars...)</code></pre><p>Return an initialisation of the model variables with given values.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">init_variables_manual(status, (Tₗ = 20.0,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/model_initialisation.jl#L245-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.inputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel" href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inputs(model::AbstractModel)
inputs(...)</code></pre><p>Get the inputs of one or several models.</p><p>Returns an empty tuple by default for <code>AbstractModel</code>s (no inputs) or <code>Missing</code> models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_inputs_outputs.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.is_initialized-Tuple{T} where T&lt;:PlantSimEngine.ModelList" href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:PlantSimEngine.ModelList"><code>PlantSimEngine.is_initialized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_initialized(m::T) where T &lt;: ModelList
is_initialized(m::T, models...) where T &lt;: ModelList</code></pre><p>Check if the variables that must be initialized are, and return <code>true</code> if so, and <code>false</code> and an information message if not.</p><p><strong>Note</strong></p><p>There is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">leaf = ModelList(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0))
is_initialized(leaf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/model_initialisation.jl#L173-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.outputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel" href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outputs(model::AbstractModel)
outputs(...)</code></pre><p>Get the outputs of one or several models.</p><p>Returns an empty tuple by default for <code>AbstractModel</code>s (no outputs) or <code>Missing</code> models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_inputs_outputs.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.pre_allocate_attr!-Tuple{Any, Any}" href="#PlantSimEngine.pre_allocate_attr!-Tuple{Any, Any}"><code>PlantSimEngine.pre_allocate_attr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pre_allocate_attr!(node, nsteps; attr_name = :models)</code></pre><p>Pre-allocate the node attributes based on the status of a component model and a given number of simulation steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/mtg/mtg_helpers.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.pull_status!-Tuple{Any}" href="#PlantSimEngine.pull_status!-Tuple{Any}"><code>PlantSimEngine.pull_status!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pull_status!(node)</code></pre><p>Copy the status of a node&#39;s component models (<em>e.g.</em> the outputs of a [<code>ModelList</code>]@ref simulation) into the MTG attributes. This function is used when we need to compute further the simulation outputs with <em>e.g.</em> <a href="@ref"><code>transform!</code></a>.</p><p><strong>Notes</strong></p><p>Carefull, this function makes a copy, so the values are then present at two locations (can take a lot of memory space if using several plants).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PlantBiophysics

# Read the file
mtg = read_mtg(joinpath(dirname(dirname(pathof(PlantBiophysics))),&quot;test&quot;,&quot;inputs&quot;,&quot;scene&quot;,&quot;opf&quot;,&quot;coffee.opf&quot;))

# Declare our models:
models = Dict(
    &quot;Leaf&quot; =&gt;
        ModelList(
            energy_balance = Monteith(),
            photosynthesis = Fvcb(),
            stomatal_conductance = Medlyn(0.03, 12.0),
            status = (d = 0.03,)
        )
)

transform!(
    mtg,
    [:Ra_PAR_f, :Ra_NIR_f] =&gt; ((x, y) -&gt; x + y) =&gt; :Rₛ,
    :Ra_PAR_f =&gt; (x -&gt; x * 4.57) =&gt; :PPFD,
    ignore_nothing = true
)

# Initialising all components with their corresponding models and initialisations:
init_mtg_models!(mtg, models)

# Make a simulation
transform!(mtg, :models =&gt; (x -&gt; energy_balance!(x, meteo)), ignore_nothing = true)
# Pull the simulation results into the MTG attributes:
transform!(mtg, pull_status!)
# Now the simulated variables are available from the MTG attributes field:
names(mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/mtg/mtg_helpers.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.pull_status_one_step!-Tuple{Any, Any}" href="#PlantSimEngine.pull_status_one_step!-Tuple{Any, Any}"><code>PlantSimEngine.pull_status_one_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pull_status_one_step!(node, step; attr_name = :models)</code></pre><p>Copy the status of a node&#39;s ModelList (<em>i.e.</em> the outputs of the simulations) into the pre-allocated MTG attributes, i.e. one value per step.</p><p>See <a href="#PlantSimEngine.pre_allocate_attr!-Tuple{Any, Any}"><code>pre_allocate_attr!</code></a> for the pre-allocation step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/mtg/mtg_helpers.jl#L71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.status-Tuple{Any}" href="#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">status(m)
status(m::AbstractArray{&lt;:ModelList})
status(m::AbstractDict{T,&lt;:ModelList})</code></pre><p>Get a ModelList status, <em>i.e.</em> the state of the input (and output) variables.</p><p>See also <a href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:PlantSimEngine.ModelList"><code>is_initialized</code></a> and <a href="#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.ModelList}"><code>to_initialize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/component_models/get_status.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.to_initialize-Tuple{PlantSimEngine.ModelList}" href="#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.ModelList}"><code>PlantSimEngine.to_initialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_initialize(v::T, vars...) where T &lt;: Union{Missing,AbstractModel}
to_initialize(m::T)  where T &lt;: ModelList
to_initialize(m::DependencyTree)</code></pre><p>Return the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">to_initialize(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0))

# Or using a component directly:
leaf = ModelList(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0))
to_initialize(leaf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/model_initialisation.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}" href="#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}"><code>PlantSimEngine.update_mtg_models!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_mtg_models!(mtg::MultiScaleTreeGraph.Node, i, attr_name::Symbol)</code></pre><p>Update the mtg models initialisations by using the ith time-step. The mtg is considered fully initialized already once, so <a href="#PlantSimEngine.init_mtg_models!"><code>init_mtg_models!</code></a> must be called before <code>update_mtg_models!</code>.</p><p>The values are updated only for node attributes in <code>to_init</code>. Those attributes must have several time-steps, <em>i.e.</em> indexable by 1:n time-steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/mtg/init_mtg_models.jl#L165-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.variables-Tuple{}" href="#PlantSimEngine.variables-Tuple{}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables()</code></pre><p>Returns a dataframe of all variables in PlantBiophysics, their description and their units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_inputs_outputs.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, PlantSimEngine.AbstractModel}" href="#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, PlantSimEngine.AbstractModel}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables(model)
variables(model, models...)</code></pre><p>Returns a tuple with the name of the variables needed by a model, or a union of those variables for several models.</p><p><strong>Note</strong></p><p>Each model can (and should) have a method for this function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">variables(Monteith())

variables(Monteith(), Medlyn(0.03,12.0))</code></pre><p><strong>See also</strong></p><p><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>inputs</code></a>, <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>outputs</code></a> and <a href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>variables_typed</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_inputs_outputs.jl#L50-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.variables_typed-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel" href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>PlantSimEngine.variables_typed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables_typed(model)
variables_typed(model, models...)</code></pre><p>Returns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">variables_typed(Monteith())

variables_typed(Monteith(), Medlyn(0.03,12.0))</code></pre><p><strong>See also</strong></p><p><a href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>inputs</code></a>, <a href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:PlantSimEngine.AbstractModel"><code>outputs</code></a> and <a href="#PlantSimEngine.variables-Tuple{}"><code>variables</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/models_inputs_outputs.jl#L86-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:PlantSimEngine.Status" href="#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:PlantSimEngine.Status"><code>PlantSimEngine.vars_not_init_</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vars_not_init_(st&lt;:Status, var_names)</code></pre><p>Get which variable is not properly initialized in the status struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/model_initialisation.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlantSimEngine.@gen_process_methods" href="#PlantSimEngine.@gen_process_methods"><code>PlantSimEngine.@gen_process_methods</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@gen_process_methods(process::String, doc::String=&quot;&quot;)</code></pre><p>This macro generate the abstract type and standard functions for a process, along with  their documentation and prints out a little tutorial about how to implement a model.</p><p>The abstract process type is then used as a supertype of all models implementations for the  process, and is named &quot;Abstract&lt;ProcessName&gt;Model&quot;, <em>e.g.</em> <code>AbstractGrowthModel</code> for a process called growth.</p><p>The three following functions are also generated (replace &quot;process&quot; by your own process name):</p><ul><li><code>process</code>: a non mutating function that makes a copy of the object</li><li><code>process!</code>: a mutating function that updates the object status</li><li><code>process!_</code>: the actual workhorse function that does the computation, and is called by the </li></ul><p>two previous functions under the hood. Modelers implement their own method for this function  for their own model types.</p><p>The two first functions have several methods:</p><ul><li>The base method that runs over one time-step and one object.</li><li>The method applying the computation over several objects (<em>e.g.</em> all leaves of a plant)</li></ul><p>in an Array</p><ul><li>The same method over a Dict(-alike) of objects</li><li>The method that applies the computation over several meteo time steps and</li></ul><p>possibly several objects</p><ul><li>A method for calling the process without any meteo (<em>e.g.</em> for fitting)</li><li>A method to apply the above over MTG nodes (see details)</li></ul><p>The first argument to <code>@gen_process_methods</code> is the new process name,  and the second is any additional documentation that should be added  to the <code>process</code> and <code>process!</code> functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@gen_process_methods &quot;dummy_process&quot; &quot;This is a dummy process that shall not be used&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/PlantSimEngine.jl/blob/6e0b2b2f9a416d901a898b7d6b49d4801880e977/src/processes/process_methods_generation.jl#L1-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model_coupling/model_coupling_modeler/">« Modelers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 9 December 2022 20:05">Friday 9 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
