var documenterSearchIndex = {"docs":
[{"location":"design/#Package-design","page":"Design","title":"Package design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to ease the process of modelling and simulation of plants, soil and atmosphere related processes, or really any system (e.g. agroforestry system, agrivoltaics...). PlantSimEngine.jl aims at being the backbone tool for developing Functional-Structural Plant Models (FSPM) and crop models without the hassle of performance and other computer-science considerations.  ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantBiophysics","category":"page"},{"location":"design/#Definitions","page":"Design","title":"Definitions","text":"","category":"section"},{"location":"design/#Processes","page":"Design","title":"Processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process in this package defines a biological or physical phenomena. Think of any process happening in a system, such as light interception, photosynthesis, water, carbon and energy fluxes, growth, yield or even electricity produced by solar panels.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A process is \"declared\", meaning we just define a process using the @gen_process_methods, and then we implement models for its simulation. Declaring a process automatically generates three functions, for example energy_balance from PlantBiophysics.jl has:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"energy_balance: the generic function that makes a copy of the modelList and returns directly the status (not very efficient but easy to use)\nenergy_balance!: the faster, mutating, generic function. Here the user need to extract the outputs from the status after the simulation (note the ! at the end of the name)\nenergy_balance!_: the internal implementation with a method for each model. PlantBiophysics then uses multiple dispatch to choose the right method based on the model type. This is the function we need to extend when implementing a new model for the process","category":"page"},{"location":"design/#Models","page":"Design","title":"Models","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A process is simulated using a particular implementation of a model. Each model is implemented using a structure that lists the parameters of the model. For example, PlantBiophysics provides the Beer structure for the implementation of the Beer-Lambert law of light extinction.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Models can use three types of entries:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters\nMeteorological information\nVariables\nConstants\nExtras","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parameters are constant values that are used by the model to compute its outputs. Meteorological information are values that are provided by the user and are used as inputs to the model. It is defined for one time-step, and PlantSimEngine.jl takes care of applying the model to each time-steps given by the user. Variables are either used or computed by the model and can optionally be initialized before the simulation. Constants are constant values, usually common between models, e.g. the universal gas constant. And extras are just extra values that can be used by a model, it is for example used to pass the current node of the Multi-Scale Tree Graph to be able to e.g. retrieve children or ancestors values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users can choose which model is used to simulate a process using the ModelList structure. ModelList is also used to store the values of the parameters, and to initialize variables.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For example let's instantiate a ModelList with the Beer-Lambert model of light extinction from PlantBiophysics.jl. The model is implemented with the Beer structure and has only one parameter: the extinction coefficient (k).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantBiophysics\nModelList(light_extinction = Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"What happened here? We provided an instance of a model to the process it simulates. The model is provided as a keyword argument to the ModelList, with the process name given as the keyword, and the instantiated model as the value. The keyword must match exactly the name of the process it simulates, e.g. photosynthesis for the photosynthesis process, because it is used to match the models to the function than run its simulation. The four processes provided by default in PlantBiophysics.jl are implemented with the following functions: light_interception, energy_balance, photosynthesis and stomatal_conductance.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"tip: Tip\nWe see that we only instantiated the ModelList for the light extinction process. What about the others like photosynthesis or energy balance ? Well there is no need to give models if we have no intention to simulate them.","category":"page"},{"location":"design/#Parameters","page":"Design","title":"Parameters","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A parameter is a constant value that is used by a model to compute its outputs. For example, the Beer-Lambert model uses the extinction coefficient (k) to compute the light extinction. The Beer-Lambert model is implemented with the Beer structure, which has only one field: k. We can see that using fieldnames:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(Beer)","category":"page"},{"location":"design/#Variables-(inputs,-outputs)","page":"Design","title":"Variables (inputs, outputs)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Variables are either input or outputs (i.e. computed) by models, and can optionally be initialized before the simulation. Variables and their values are stored in the ModelList structure, and are initialized automatically or manually.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Hence, ModelList objects stores two fields:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"fieldnames(ModelList)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first field is a list of models associated to the processes they simulate. The second, :status, is used to hold all inputs and outputs of our models, called variables. For example the Beer model needs the leaf area index (LAI, m^{2} \\cdot m^{-2}) to run.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can see which variables are needed as inputs using inputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantBiophysics\ninputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can also see the outputs of the model using outputs:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"outputs(Beer(0.5))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"If we instantiate a ModelList with the Beer-Lambert model, we can see that the :status field has two variables: LAI and PPDF. The first is an input, the second an output (i.e. it is computed by the model).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_extinction = Beer(0.5))\nkeys(m.status)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To know which variables should be initialized, we can use to_initialize:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_extinction = Beer(0.5))\n\nto_initialize(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Their values are uninitialized though (hence the warnings):","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"(m[:LAI], m[:PPFD])","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Uninitialized variables have the value returned by typemin(), e.g. -Inf for Float64:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"typemin(Float64)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"tip: Tip\nPrefer using to_initialize rather than inputs to check which variables should be initialized. inputs returns the variables that are needed by the model to run, but to_initialize returns the variables that are needed by the model to run and that are not initialized. Also to_initialize is more clever when coupling models (see below).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can initialize the variables by providing their values to the status at instantiation:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_extinction = Beer(0.5), status = (LAI = 2.0,))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or after instantiation using init_status!:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"m = ModelList(light_extinction = Beer(0.5))\n\ninit_status!(m, LAI = 2.0)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can check if a component is correctly initialized using is_initialized:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"is_initialized(m)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Some variables are inputs of models, but outputs of other models. When we couple models, we have to be careful to initialize only the variables that are not computed, and PlantSimEngine.jl is here to help users in this task.","category":"page"},{"location":"design/#Climate-forcing","page":"Design","title":"Climate forcing","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"To make a simulation, we usually need the climatic/meteorological conditions measured close to the object or component.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Users are strongly encouraged to use PlantMeteo.jl, the companion package that helps manage such data, with default pre-computations and structures for efficient computations. The most basic data structure from this package is a type called Atmosphere, which defines steady-state atmospheric conditions, i.e. the conditions are considered at equilibrium. Another structure is available to define different consecutive time-steps: Weather.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The mandatory variables to provide for an Atmosphere are: T (air temperature in °C), Rh (relative humidity, 0-1) and Wind (the wind speed in m s-1). We can declare such conditions like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"meteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"More details are available from the package documentation.","category":"page"},{"location":"design/#Simulation","page":"Design","title":"Simulation","text":"","category":"section"},{"location":"design/#Simulation-of-processes","page":"Design","title":"Simulation of processes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Making a simulation is rather simple, we simply use the function with the name of the process we want to simulate, for example PlantBiophysics.jl implements:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"stomatal_conductance for the stomatal conductance\nphotosynthesis for the photosynthesis\nenergy_balance for the energy balance\nlight_interception for the energy balance","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nAll functions exist in a mutating and a non-mutating form. Just add ! at the end of the name of the function (e.g. energy_balance!) to use the mutating form for speed! 🚀","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The call to the function is the same whatever the model you choose for simulating the process. This is some magic allowed by PlantSimEngine.jl! A call to a function is made as follows:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"stomatal_conductance(model_list, meteo)\nphotosynthesis(model_list, meteo)\nenergy_balance(model_list, meteo)\nlight_interception(model_list, meteo)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The first argument is the model list (see ModelList), and the second defines the micro-climatic conditions.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The ModelList should be initialized for the given process before calling the function. See Variables (inputs, outputs) for more details.","category":"page"},{"location":"design/#Example-simulation","page":"Design","title":"Example simulation","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"For example we can simulate the stomatal_conductance of a leaf like so:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using PlantSimEngine, PlantBiophysics, PlantMeteo\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\n\nleaf = ModelList(\n    stomatal_conductance = Medlyn(0.03, 12.0),\n    status = (A = 20.0, Cₛ = 400.0, Dₗ = meteo.VPD)\n)\n\nstomatal_conductance!(leaf, meteo)\n\nleaf[:Gₛ]","category":"page"},{"location":"design/#Outputs","page":"Design","title":"Outputs","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The status field of a ModelList is used to initialize the variables before simulation and then to keep track of their values during and after the simulation. We can extract the simulation outputs of a model list using the status function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nGetting the status is only useful when using the mutating version of the function (e.g. energy_balance!), as the non-mutating version returns the output directly.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The status usually is stored in a TimeStepTable structure with each time step being a Status, but it can be any Tables.jl structure, such as a DataFrame.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's look at the status of our previous simulated leaf:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We can extract the value of one variable using the status function, e.g. for the assimilation:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"status(leaf, :Gₛ)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or similarly using the dot syntax:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf.status.Gₛ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Or much simpler (and recommended), by indexing directly the model list:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"leaf[:Gₛ]","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Another simple way to get the results is to transform the outputs into a DataFrame:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using DataFrames\nDataFrame(leaf)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nThe output from DataFrame is adapted to the kind of simulation you did: one row per time-step, and per component models if you simulated several.","category":"page"},{"location":"design/#Model-coupling","page":"Design","title":"Model coupling","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"A model can work either independently or in conjunction with other models. For example a stomatal conductance model is often associated with a photosynthesis model, i.e. it is called from the photosynthesis model.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"PlantSimEngine.jl is designed to make model coupling painless for the modeler, and for the user. The modeler implements a model, and if the model needs another model to compute one of its variable, the modeler only needs to call the generic function for the process, and then the user choose which model is used for this computation.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"See Model coupling for users and Model coupling for modelers for more details.","category":"page"},{"location":"model_coupling/model_coupling_modeler/#Model-coupling-for-modelers","page":"Modelers","title":"Model coupling for modelers","text":"","category":"section"},{"location":"model_coupling/model_coupling_modeler/","page":"Modelers","title":"Modelers","text":"<!– Make an example model coupling here (present e.g. FVCB) –>","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-process","page":"Processes","title":"Implement a new process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"using PlantSimEngine\nusing PlantBiophysics\nPlantSimEngine.@gen_process_methods growth","category":"page"},{"location":"extending/implement_a_process/#Introduction","page":"Processes","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"PlantSimEngine.jl was designed to make the implementation of new processes and models easy and fast. Let's learn about how to implement your own process with a simple example: implementing a growth model.","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-process-2","page":"Processes","title":"Implement a new process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To implement a new process, we need to define the generic methods associated to it that helps run its simulation for:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"one or several time-steps\none or several objects\nan MTG from MultiScaleTreeGraph","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"...and all the above with a mutating function and a non-mutating one.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This is a lot of work! But fortunately PlantBiophysics provides a macro to generate all of the above: gen_process_methods.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This macro takes only one argument: the name of the non-mutating function.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"So for example all the photosynthesis methods in the PlantBiophysics.jl package are created using just this tiny line of code:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@gen_process_methods photosynthesis","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"So for example if we want to simulate the growth of a plant, we could add a new process called growth. To create the generic functions to simulate the growth we would do:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"@gen_process_methods growth","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"And that's it! Note that the function guides you in the steps you can make after creating a process. Let's break it up here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"So what you just did is to create a new process called growth. By doing so, you created three new functions:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"growth!: the mutating function\ngrowth: the non-mutating function\ngrowth!_: the function that actually make the computation. You'll have to implement methods for each model you need, else it will not work.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Now users can call growth! and growth on any number of time steps or objects, even on MTGs, and PlantSimEngine will handle everything.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Creating the process also defined a default abstract type for the process that is used as a supertype for the models types. This abstract type is always named using the process name in title case (using titlecase()), prefixed with Abstract and suffixed with Model. So in our case our process abstract type is named AbstractGrowthModel.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"note: Note\nIf you don't understand what a supertype is, no worries, you'll understand in the examples below","category":"page"},{"location":"extending/implement_a_process/#Implement-a-new-model-for-the-process","page":"Processes","title":"Implement a new model for the process","text":"","category":"section"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"To better understand how models are implemented, you can read the detailed instructions from the previous section. But for the sake of completeness, we'll implement a growth model here.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"This growth model uses the assimilation computed using the coupled energy balance process from PlantBiophysics.jl. Then it removes the maintenance respiration and the growth respiration from that source of carbon, and increments the leaf biomass by the remaining carbon offer.","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Let's implement this model below:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"# Let's import our package:\nusing PlantSimEngine\n# PlantMeteo for using the meteorology-related functions:\nusing PlantMeteo\n# And PlantBiophysics because we want our model to compute growth based on \n# photosynthesis computed from `energy_balance!_()`:\nusing PlantBiophysics\n\n# Make the struct to hold the parameters, with its documentation:\n\"\"\"\n    DummyGrowth(Rm_factor, Rg_cost)\n    DummyGrowth(;Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the leaf biomass growth of a plant.\n\n# Arguments\n\n- `Rm_factor`: the fraction of assimilation that goes into maintenance respiration\n- `Rg_cost`: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\"\"\"\nstruct DummyGrowth{T} <: AbstractGrowthModel\n    Rm_factor::T\n    Rg_cost::T\nend\n\n# Note that DummyGrowth is a subtype of AbstractGrowthModel, this is important\n\n# Instantiate the struct with default values + kwargs:\nfunction DummyGrowth(;Rm_factor = 0.5, Rg_cost = 1.2)\n    DummyGrowth(promote(Rm_factor,Rg_cost)...)\nend\n\n# Define inputs:\nfunction PlantSimEngine.inputs_(::DummyGrowth)\n    (A=-999.99,)\nend\n\n# Define outputs:\nfunction PlantSimEngine.outputs_(::DummyGrowth)\n    (Rm=-999.99, Rg=-999.99, leaf_allocation=-999.99, leaf_biomass=0.0)\nend\n\n# Tells Julia what is the type of elements:\nBase.eltype(x::DummyGrowth{T}) where {T} = T\n\n# Implement the photosynthesis model:\nfunction growth!_(::DummyGrowth, models, status, meteo, constants=Constants())\n\n    # Compute the energy balance of the plant, coupled to the photosynthesis model:\n    PlantBiophysics.energy_balance!_(models.energy_balance, models, status, meteo)\n    # Here we expect the assimilation of the plant, which is the source for Carbon\n\n    # The maintenance respiration is simply a factor of the assimilation:\n    status.Rm = status.A * models.growth.Rm_factor\n\n    # Let's say that all carbon is allocated to the leaves:\n    status.leaf_allocation = status.A - status.Rm\n\n    # And that this carbon is allocated with a cost (growth respiration Rg):\n    status.Rg = 1 - (status.leaf_allocation / models.growth.Rg_cost)\n\n    status.leaf_biomass = status.leaf_biomass + status.leaf_allocation - status.Rg\nend","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"Now we can make a simulation as usual:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        # Processes and models from PlantBiophysics:\n        energy_balance = Monteith(),\n        photosynthesis = Fvcb(),\n        stomatal_conductance = Medlyn(0.03, 12.0),\n        # Our process and associated model:\n        growth = DummyGrowth(),\n        status = (Rₛ = 13.747, sky_fraction = 1.0, PPFD = 1500.0, d = 0.03)\n    )\n\ngrowth!(leaf,meteo)\n\nleaf[:leaf_biomass] # biomass in gC","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"We can also start the simulation later when the plant already has some biomass by initializing the leaf_biomass:","category":"page"},{"location":"extending/implement_a_process/","page":"Processes","title":"Processes","text":"meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        energy_balance = Monteith(),\n        photosynthesis = Fvcb(),\n        stomatal_conductance = Medlyn(0.03, 12.0),\n        growth = DummyGrowth(),\n        status = (Rₛ = 13.747, sky_fraction = 1.0, PPFD = 1500.0, d = 0.03, leaf_biomass = 2400.0)\n    )\n\ngrowth!(leaf,meteo)\n\nleaf[:leaf_biomass] # biomass in gC","category":"page"},{"location":"extending/implement_a_model/#model_implementation_page","page":"Models","title":"Model implementation in 5 minutes","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"using PlantSimEngine\nusing PlantBiophysics","category":"page"},{"location":"extending/implement_a_model/#Introduction","page":"Models","title":"Introduction","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.jl was designed to make new model implementation very simple. So let's learn about how to implement your own model with a simple example: implementing a new stomatal conductance model.","category":"page"},{"location":"extending/implement_a_model/#Inspiration","page":"Models","title":"Inspiration","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"If you want to implement a new model, the best way to do it is to start from another implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So for a photosynthesis model, I advise you to look at the implementation of the FvCB model from PlantBiophysics.jl, available from this Julia file: src/photosynthesis/FvCB.jl.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For an energy balance model you can look at the implementation of the Monteith model in src/energy/Monteith.jl, and for a stomatal conductance model in src/conductances/stomatal/medlyn.jl.","category":"page"},{"location":"extending/implement_a_model/#Requirements","page":"Models","title":"Requirements","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"In those files, you'll see that in order to implement a new model you'll need to implement:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"a structure, used to hold the parameter values and to dispatch to the right method\nthe actual model, developed as a method for the process it simulates\nsome helper functions used by the package and/or the users","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Let's take a simple example with a new model for the stomatal conductance: the Ball and Berry model.","category":"page"},{"location":"extending/implement_a_model/#Example:-the-Ball-and-Berry-model","page":"Models","title":"Example: the Ball and Berry model","text":"","category":"section"},{"location":"extending/implement_a_model/#The-structure","page":"Models","title":"The structure","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first thing to do is to implement a structure for your model.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The purpose of the structure is two-fold:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"hold the parameter values\ndispatch to the right method when calling the process function","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Let's take the stomatal conductance model from Medlyn et al. (2011) as a starting point. The structure of the model (or type) is defined as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct Medlyn{T} <: AbstractStomatal_ConductanceModel\n    g0::T\n    g1::T\n    gs_min::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first line defines the name of the model (Medlyn), with the types that will be used for the parameters. Then it defines the structure as a subtype of AbstractStomatal_ConductanceModel. This step is very important as it tells to the package what kind of process the model simulates. In this case, it is a model for the stomatal conductance process, which is defined in PlantBiophysics.jl. We would use AbstractPhotosynthesisModel instead for a photosynthesis model, AbstractEnergy_BalanceModel for an energy balance model, and AbstractLight_InterceptionModel for a light interception model.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For another example, the Fvcb model is a subtype of AbstractPhotosynthesisModel. You can check this using:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Fvcb <: AbstractPhotosynthesisModel","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Then comes the parameters names, and their types. The type of the parameters is always forced to be of the same type in our example. This is done using the T notation as follows:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"we say that our structure Medlyn is a parameterized struct by putting T in between brackets after the name of the struct\nWe put ::T after our parameter names in the struct. This way Julia knows that all parameters must be of same type T.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The T is completely free, you can use any other letter or word instead. If you have parameters that you know will be of different types, you can either force their type, or make them parameterizable too, using another letter, e.g.:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct{T,S} <: PlantBiophysics.AbstractStomatal_ConductanceModel\n    g0::T\n    g1::T\n    gs_min::T\n    integer_param::S\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Parameterized types are very useful because they let the user choose the type of the parameters, and potentially dispatch on them.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"But why not forcing the type such as the following:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct YourStruct <: PlantBiophysics.AbstractStomatal_ConductanceModel\n    g0::Float64\n    g1::Float64\n    gs_min::Float64\n    integer_param::Int\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Well, you can do that. But you'll lose a lot of the magic Julia has to offer this way.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"For example a user could use the Particles type from MonteCarloMeasurements.jl to make automatic uncertainty propagation, and this is only possible if the type is parameterizable.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So let's implement a new structure for our stomatal conductance model:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct BandB{T} <: PlantBiophysics.AbstractStomatal_ConductanceModel\n    g0::T\n    g1::T\n    gs_min::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Well, the only thing we had to change relative to the one from Medlyn is the name, easy! This is because both models share the same parameters.","category":"page"},{"location":"extending/implement_a_model/#The-method","page":"Models","title":"The method","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The models are implemented in a function named after the process and a \"!_\" as a suffix. The exclamation point is used in Julia to tell users the function is mutating, i.e. it modifies its input.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Your implementation should always modify the input status and return nothing. This ensures that models compute fast. The \"_\" suffix is used to tell users that this is the internal implementation, which is only used by modelers.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Remember that PlantSimEngine only exports the generic functions of the processes to users because they are the one that handles every other details, such as checking that the object is correctly initialized, and applying the computations over objects and time-steps. This is nice because as a developer you don't have to deal with those details, and you can just concentrate on your implementation.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"However, you have to remember that if your model calls another one, you'll have to use the internal implementation directly to avoid the overheads of the generic functions (you don't want all these checks).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So if you want to implement a new photosynthesis model, you have to make your own method for the photosynthesis!_ function. But here we are trying to implement a new stomatal conductance model. Well, this one is the most complicated process to implement actually, because it is computed in two steps: stomatal_conductance!_ and gs_closure.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"gs_closure is the function that actually implements the conductance model, but only the stomatal closure part. This one does not modify its input, it computes the result and returns it. Then stomatal_conductance!_ uses this output to compute the stomatal conductance. But why not implementing just stomatal_conductance!_? Because gs_closure is used elsewhere, usually in the photosynthesis model, before actually computing the stomatal conductance.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So in practice, the stomatal_conductance!_ implementation is rather generic and will not be modified by developers. They will rather implement their method for gs_closure, that will be used automatically by stomatal_conductance!_.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"warning: Warning\nWe need to import all the functions we need to use or extend, so Julia knows we are extending the methods from PlantSimEngine and/or PlantBiophysics, and not defining our own functions. To do so, you can prefix the said functions by the package name, or import them before e.g.: `import PlantSimEngine: inputs, outputs","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So let's do it! Here is our own implementation of the stomatal closure for a ModelList component models:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function PlantBiophysics.gs_closure(::BandB, models, status, meteo, constants, extras)\n    models.stomatal_conductance.g1 * meteo.Rh / status.Cₛ\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The first argument (::BandB) means this method will only execute when the function is called with a first argument that is of type BandB. This is our way of telling Julia that this method is implementing the BandB algorithm.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"An important thing to note is that our variables are stored in different structures:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"models: the models parameters\nmeteo: the micro-climatic conditions\nstatus: the input and output variables of the models\nconstants: the constants\nextras: any other value or object","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"note: Note\nThe micro-meteorological conditions are always given for one time-step inside the models methods, so they are always of Atmosphere type. The Weather type of conditions are handled earlier by the generic functions.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"OK ! So that's it ? Almost. One last thing to do is to define a method for inputs/outputs so that PlantSimEngine knows which variables are needed for our model, and which it computes. Remember that the actual model is implemented for stomatal_conductance!_, so we have to tell PlantSimEngine which ones are needed, and what are their default value:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Inputs: :Rh and :Cₛ for our specific implementation, and :A for stomatal_conductance!_\nOutputs: our model does not compute any new variable, and stomatal_conductance!_ computes, well, :Gₛ","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here is how we actually implement our methods:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function PlantSimEngine.inputs_(::BandB)\n    (Rh=-999.99,Cₛ=-999.99,A=-999.99)\nend\n\nfunction PlantSimEngine.outputs_(::BandB)\n    (Gₛ=-999.99,)\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Note that both function end with an \"\". This is because these functions are internal, they will not be called by the users directly. Users will use inputs and outputs instead, which call `inputsandoutputs_`, but stripping out the default values.","category":"page"},{"location":"extending/implement_a_model/#The-utility-functions","page":"Models","title":"The utility functions","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Before running a simulation, you can do a little bit more for your implementation (optional).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"First, you can add a method for type promotion:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function BandB(g0,g1,gs_min)\n    BandB(promote(g0,g1,gs_min))\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This allows your user to instantiate your model parameters using different types of inputs. For example they may use this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"BandB(0,2.0,0.001)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"You don't see a problem? Well your users won't either.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here's the problem: we use parametric types, and when we declared our structure, we said that all fields in our type will share the same type. This is the T here:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"struct BandB{T} <: PlantBiophysics.AbstractStomatal_ConductanceModel\n    g0::T\n    g1::T\n    gs_min::T\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"And in our example above, the user provides 0 as the first argument. Well, this is an integer, not a floating point number like the two others. That's were the promotion is really helpful. It will convert all your inputs to the same type. In our example it will convert 0 to 0.0.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"A second thing also is to help your user with default values for some parameters (if applicable). For example a user will almost never change the value of the minimum stomatal conductance. So we can provide a default value like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"BandB(g0,g1) = BandB(g0, g1, oftype(0.001, g0))","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Now the user can call BandB with only two values, and the third one will be set to 0.001.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Another useful thing to provide to the user is the ability to instantiate your model type with keyword values. You can do it by adding the following method:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"BandB(;g0,g1) = BandB(g0,g1,oftype(g0,0.001))","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Did you notice the ; before the argument? It tells Julia that we want those arguments provided as keywords, so now we can call BandB like this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"BandB(g0 = 0.0, g1 = 2.0)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This is nice, but again, completely optional.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"One more thing to implement is a method for the dep function that tells PlantSimEngine which processes (and models) are needed for your model to run (i.e. if your model is coupled to another model).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Our example model does not call another model, so we don't need to implement it. But we can look at e.g. the implementation for Fvcb to see how it works:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"PlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here we say to PlantSimEngine that the Fvcb model needs a model of type AbstractStomatal_ConductanceModel in the stomatal conductance process.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The last optional thing to implement is a method for the eltype function:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Base.eltype(x::BandB{T}) where {T} = T","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"This one helps Julia to know the type of the elements in your structure, and make it faster.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"OK that's it! Now you have a full new implementation of the stomatal conductance model! I hope it was clear and you understood everything. If you think some sections could be improved, you can make a PR on this doc, or open an issue so I can improve it.","category":"page"},{"location":"extending/implement_a_model/#More-details-on-model-implementations","page":"Models","title":"More details on model implementations","text":"","category":"section"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Here is another example with a different approach in case you need it. So let's change our example from the stomatal conductance to the photosynthesis. For example Fvcb implements the model or Farquhar et al. (1980) to simulate the photosynthesis process of C3 plants.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"When the user calls the photosynthesis function, or its mutating version photosynthesis!, PlantSimEngine looks into the component models type, and the type of the model implemented for the photosynthesis, in this case, Fvcb.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Then, it calls the internal function photosynthesis!_ that will dispatch the computation to the method that implements the model. This method looks like this:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"function photosynthesis!_(::Fvcb, models, status, meteo, constants=Constants(), extras=nothing)\n\n    [...]\n\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Where [...] represent the lines of code implementing the model (not shown here).","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The interesting bit is in the function declaration at the top. This is where all the magic happens. The first argument let Julia know that this is the method for computing the photosynthesis using the Fvcb model.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Now if we look again at what are the fields of a ModelList:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"fieldnames(ModelList)","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"we see that it has two fields: models and status. The first one is a list of models named after the process they simulate. So if we want to simulate the photosynthesis with the Fvcb model, our ModelList needs an instance of the Fvcb structure for the photosynthesis process, like so:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"leaf = ModelList(photosynthesis = Fvcb());\nleaf.models.photosynthesis","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"The photosynthesis field is then used as the first argument to the call to the internal function photosynthesis!_, which will call the method that implements Fvcb, because our photosynthesis field is of type Fvcb.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"So if we want to implement our own model for the photosynthesis, we could do:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"# Make the struct to hold the parameters:\nstruct OurModel{T} <: PlantBiophysics.AbstractPhotosynthesisModel\n    a::T\n    b::T\n    c::T\nend\n\n# Instantiate the struct with default values + kwargs:\nfunction OurModel(;a = 400.0, b = 1000.0, c = 1.5)\n    OurModel(promote(a,b)...)\nend\n\n# Define inputs:\nfunction PlantSimEngine.inputs_(::OurModel)\n    (PPFD=-999.99, Tₗ=-999.99, Cₛ=-999.99)\nend\n\n# Define outputs:\nfunction PlantSimEngine.outputs_(::OurModel)\n    (A=-999.99, Gₛ=-999.99)\nend\n\n# Tells Julia what is the type of elements:\nBase.eltype(x::OurModel{T}) where {T} = T\n\n# Implement the photosynthesis model (note that we prefix with PlantBiophysics to tell julia we add a method, not create a function):\nfunction PlantBiophysics.photosynthesis!_(::OurModel, models, status, meteo, constants=Constants(), extras=nothing)\n\n    status.A =\n        status.Cₛ / models.photosynthesis.a +\n        status.PPFD / models.photosynthesis.b +\n        status.Tₗ / models.photosynthesis.c\n\n    PlantBiophysics.stomatal_conductance!_(models.stomatal_conductance, models, status, meteo, extras)\nend","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"🥳 And that's it! 🥳","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"We have a new model for photosynthesis that is coupled with the stomatal conductance.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"warning: Warning\nThis is a dummy photosynthesis model. Don't use it, it is very wrong biologically speaking!","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"note: Note\nNotice that we compute the stomatal conductance directly using the internal function stomatal_conductance!_. We do this for speed, because the generic function stomatal_conductance! does some checks on its inputs every time it is called, while stomatal_conductance!_ only does the computation. We don't need the extra checks because they are already made when calling photosynthesis!.","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"Now if we want to make a simulation, we can simply do:","category":"page"},{"location":"extending/implement_a_model/","page":"Models","title":"Models","text":"meteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\n\nleaf =\n    ModelList(\n        photosynthesis = OurModel(1.0, 2.0, 3.0),\n        stomatal_conductance = Medlyn(0.03, 12.0),\n        status = (Tₗ = 25.0, PPFD = 1000.0, Cₛ = 400.0, Dₗ = meteo.VPD)\n    )\n# NB: we need  to initalise Tₗ, PPFD and Cₛ\n\nphotosynthesis!(leaf,meteo,Constants())\nleaf[:A]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"#PlantSimEngine","page":"Home","title":"PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlantSimEngine defines a framework for declaring processes and implementing associated models for their simulation. The package focuses on key aspects of simulation and modelling:","category":"page"},{"location":"","page":"Home","title":"Home","text":"easy definition of new processes, which can really be any process such as light interception, photosynthesis, growth, soil water transfer...\neasy, interactive prototyping of models, with constraints to help users avoid errors, but sensible defaults to avoid over-complicating the model writing process\nno hassle, the package manages automatically input and output variables, time-steps, objects, model coupling, and model switching\n(very) fast computing, think of 100th of nanoseconds for the full energy balance of a leaf (see PlantBiophysics.jl that uses PlantSimEngine)\neasily scalable, with methods for computing over objects, time-steps and even Multi-Scale Tree Graphs\ncomposable: use Unitful to propagate units, use MonteCarloMeasurements.jl to propagate measurement error","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, enter the Julia package manager mode by pressing ] in the REPL, and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add PlantSimEngine","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, execute this command from the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PlantSimEngine","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the First simulation section for examples.","category":"page"},{"location":"#Make-it-yours","page":"Home","title":"Make it yours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed so anyone can easily implement plant/crop models, use it freely and as you want, we have an MIT license. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you develop such tools and it is not on the list yet, please make a PR or contact me so we can add it! 😃","category":"page"},{"location":"#Projects-that-use-PlantSimEngine","page":"Home","title":"Projects that use PlantSimEngine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Take a look at these projects that use PlantSimEngine:","category":"page"},{"location":"","page":"Home","title":"Home","text":"PlantBiophysics.jl\nXPalm","category":"page"},{"location":"model_coupling/model_coupling_user/#Model-coupling-for-users","page":"Users","title":"Model coupling for users","text":"","category":"section"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"using PlantSimEngine","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"PlantSimEngine.jl is designed to make model coupling simple for both the modeler and the user. For example, PlantBiophysics.jl implements the Fvcb model to simulate the photosynthesis process. This model needs the stomatal conductance process to be simulated, so it calls the stomatal_conductance_ function at some point. Note that it does not force any model for its computation, just the process. This ensures that users can choose whichever model they want to use for this simulation, independent of the photosynthesis model. ","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"So in practice, using Fvcb requires a stomatal conductance model in the ModelList to compute Gₛ. We can use the one from Medlyn et al. (2011) as an example:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03, 12.0))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Note that the user only declares the models, not the way the models are coupled, because PlantSimEngine.jl deals with that automatically.","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Now the example above returns some warnings saying we need to initialize some variables. The Fvcb model requires the following variables as inputs:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"inputs(Fvcb())","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"And the Medlyn model requires the following variables:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"inputs(Medlyn(0.03, 12.0))","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"We see that A is needed as input of Medlyn, but we also know that it is an output of Fvcb. This is why we prefer using to_initialize instead of inputs, because it returns only the variables that need to be initialized, considering that some inputs are duplicated between models, and some are computed by other models (they are outputs of a model):","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    photosynthesis = Fvcb(),\n    stomatal_conductance = Medlyn(0.03, 12.0)\n)\n\nto_initialize(m)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"The most straightforward way of initializing a model list is by giving the initializations to the status keyword argument during instantiation:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"m = ModelList(\n    photosynthesis = Fvcb(),\n    stomatal_conductance = Medlyn(0.03, 12.0),\n    status = (Tₗ = 25.0, PPFD = 1000.0, Cₛ = 400.0, Dₗ = 0.82)\n)","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Our component models structure is now fully parameterized and initialized for a simulation!","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"Let's simulate it:","category":"page"},{"location":"model_coupling/model_coupling_user/","page":"Users","title":"Users","text":"photosynthesis(m)","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#API-documentation","page":"API","title":"API documentation","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [PlantSimEngine]\n# Private = false","category":"page"},{"location":"API/#DataFrames.DataFrame-Tuple{T} where T<:ModelList","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::T) where {T<:ModelList}\n\nGeneric implementation of DataFrame for a single ModelList model.\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Tuple{T} where T<:Union{AbstractArray{<:ModelList}, ModelList}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:Status}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:AbstractDict}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"API/#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:TimeStepTable}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,<:TimeStepTable})\n\nImplementation of DataFrame for a ModelList model with several time steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.AbstractModel","page":"API","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one, see e.g. AbstractAModel\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.ModelList","page":"API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    init_fun::Function=init_fun_default,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\n- `models`: a list of models. Usually given as a `NamedTuple`, but can be any other structure that \nimplements `getproperty`.\n- `status`: a structure containing the initializations for the variables of the models. Usually a NamedTuple\nwhen given as a kwarg, or any structure that implements the Tables interface from `Tables.jl` (*e.g.* DataFrame).\n- `init_fun`: a function that initializes the status based on a vector of NamedTuples (see details).\n- `type_promotion`: optional type conversion for the variables with default values.\n`nothing` by default, *i.e.* no conversion. Note that conversion is not applied to the\nvariables input by the user as `kwargs` (need to do it manually).\nShould be provided as a Dict with current type as keys and new type as values.\n- `variables_check=true`: check that all needed variables are initialized by the user.\n- `kwargs`: the models, named after the process they simulate.\n\nDetails\n\nThe argument init_fun is set by default to init_fun_default which initializes the status with a TimeStepTable of Status structures.\n\nIf you change init_fun by another function, make sure the type you are using (i.e. in place of TimeStepTable)  implements the Tables.jl interface (e.g. DataFrame does). And if you still use TimeStepTable but only change Status, make sure the type you give is indexable using the dot synthax (e.g. x.var).\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized.\n\nExamples\n\nA leaf with a width of 0.03 m, that uses the Monteith and Unsworth (2013) model for energy balance, the Farquhar et al. (1980) model for photosynthesis, and a constant stomatal conductance for CO₂ of 0.0011 with no residual conductance.\n\nusing PlantBiophysics\n\nleaf = ModelList(\n    energy_balance = Monteith(),\n    photosynthesis = Fvcb(),\n    stomatal_conductance = ConstantGs(0.0, 0.0011)\n)\n\nNo variables were given as keyword arguments, that means that the status of the leaf is not set yet, and all variables are initialized to typemin(Type), i.e. -Inf for floating point numbers. This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\nto_initialize(leaf)\n\nThe meaning and units of the variables can be found on the documentation of each model, e.g. here for photosynthesis.\n\nWe can now provide values for these variables:\n\nleaf = ModelList(\n    energy_balance = Monteith(),\n    photosynthesis = Fvcb(),\n    stomatal_conductance = ConstantGs(0.0, 0.0011),\n    status = (Rₛ = 13.747, sky_fraction = 1.0, d = 0.03, PPFD = 1500)\n)\n\nWe can now simulate the leaf, e.g. for the energy_balance (coupled to photosynthesis and stomatal conductance):\n\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nenergy_balance!(leaf,meteo)\n\nDataFrame(leaf)\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\nleaf = ModelList(\n    energy_balance = Monteith(),\n    photosynthesis = Fvcb(),\n    stomatal_conductance = ConstantGs(0.0, 0.0011),\n    status = (Rₛ = 13.747, sky_fraction = 1.0, d = 0.03, PPFD = 1500),\n    type_promotion = Dict(Float64 => Float32)\n)\n\nWe can also use DataFrame as the status type:\n\nusing DataFrames\ndf = DataFrame(:Rₛ => [13.747, 13.8], :sky_fraction => [1.0, 1.0], :d => [0.03, 0.03], :PPFD => [1300.0, 1500.0])\nm = ModelList(\n    energy_balance=Monteith(),\n    photosynthesis=Fvcb(),\n    stomatal_conductance=Medlyn(0.03, 12.0),\n    status=df,\n    init_fun=x -> DataFrame(x)\n)\n\n# Note that we use `init_fun` to force the status into a `DataFrame`,\n# otherwise it would be automatically converted into a `TimeStepTable{Status}`.\n\nNote that computations will be slower using DataFrame, so if performance is an issue, use TimeStepTable instead (or a NamedTuple as shown in the example).\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.Status","page":"API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\n# A leaf with one value for all variables will make a status with one time step:\nst = Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, PPFD=1500.0)\n\n# Indexing a Status with a symbol returns the value of the variable:\nst[:Tₗ]\n\n# Indexing the Status with an integer returns the value of the variable by position:\nst[1]\n\n\n\n\n\n","category":"type"},{"location":"API/#PlantSimEngine.TimeStepTable","page":"API","title":"PlantSimEngine.TimeStepTable","text":"TimeStepTable(vars)\nTimeStepTable{Status}(df::DataFrame)\n\nTimeStepTable stores the values of the variables for each time step of a simulation. For example, it is used as the structure in the status field of the ModelList type.\n\nTimeStepTable implements the Tables.jl interface, so it can be used with any package that uses Tables.jl (like DataFrames.jl).\n\nExamples\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nleaf = ModelList(\n    photosynthesis = Fvcb(),\n    stomatal_conductance = Medlyn(0.03, 12.0),\n    status=(Tₗ=[25.0, 26.0], PPFD=1000.0, Cₛ=400.0, Dₗ=1.0)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(leaf)\n\n\n# Of course we can also create a TimeStepTable manually:\nTimeStepTable(\n    [\n        Status(Tₗ=25.0, PPFD=1000.0, Cₛ=400.0, Dₗ=1.0),\n        Status(Tₗ=26.0, PPFD=1200.0, Cₛ=400.0, Dₗ=1.2),\n    ]\n)\n\n# We can also create a TimeStepTable from a DataFrame:\nusing DataFrames\ndf = DataFrame(\n    Tₗ=[25.0, 26.0],\n    PPFD=[1000.0, 1200.0],\n    Cₛ=[400.0, 400.0],\n    Dₗ=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.copy-Tuple{T} where T<:ModelList","page":"API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nlm = ModelList(\n    energy_balance = Monteith(),\n    photosynthesis = Fvcb(),\n    stomatal_conductance = ConstantGs(0.0, 0.0011),\n    status = (Cᵢ = 380.0, Tₗ = [20.0, 25.0])\n)\n\nlm[:Tₗ] # Returns the value of the Tₗ variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:Tₗ] # Returns the value of Tₗ at the second time-step\nlm[:Tₗ][2] # Equivalent of the above\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.EF-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations `obs` and simulations `sim` using NSE (Nash-Sutcliffe efficiency) model.\nMore information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe_model_efficiency_coefficient.\n\nThe closer to 1 the better.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations `obs` and simulations `sim`.\nNormalization is performed using division by observations range (max-min).\n\nOutput: Float/Particles\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations `obs` and simulations `sim`.\n\nThe closer to 0 the better.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are unitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x (please do it if you need it).\n\nCareful, the function mutates x in place for performance. We don't put the ! in the name just because it also returns it (impossible to mutate when x is nothing)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}","page":"API","title":"PlantSimEngine.convert_vars","text":"convert_vars(type_promotion::Dict{DataType,DataType}, ref_vars)\nconvert_vars(type_promotion::Nothing, ref_vars)\n\nConvert the status variables to the type specified in the type promotion dictionary.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nref_vars = init_variables(energy_balance=Monteith(), photosynthesis=Fvcb(), stomatal_conductance=Medlyn(0.03, 12.0))\ntype_promotion = Dict(Real => Float32)\n\nconvert_vars(type_promotion, ref_vars)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.dep-Tuple{}","page":"API","title":"PlantSimEngine.dep","text":"dep(models::ModelList; verbose::Bool=true)\n\nGet the model dependency tree given a ModelList. If one tree is returned, then all models are coupled. If several trees are returned, then only the models inside each tree are coupled, and the models in different trees are not coupled.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.dr-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmott’s refined index of agreement dᵣ.\nWillmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_dependency_tree-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.draw_dependency_tree","text":"draw_dependency_tree(\n    tree, node;\n    guides_style::String=TERM_THEME[].tree_guide_style,\n    dep_tree_guides=(space=\" \", vline=\"│\", branch=\"├\", leaf=\"└\", hline=\"─\")\n)\n\nDraw the dependency tree.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency tree.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.draw_panel-NTuple{4, Any}","page":"API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, tree, prefix, dep_tree_guides)\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.get_attr_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Nothing","page":"API","title":"PlantSimEngine.get_attr_i","text":"get_attr_i(node, attr, i<:Nothing)\nget_attr_i(node, attr, i)\n\nGet node attribute at ith value or only value if i<:Nothing\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nhomogeneous_ts_kwargs((Tₗ=[25.0, 26.0], PPFD=1000.0))\n# [(Tₗ=25.0, PPFD=1000.0), (Tₗ=26.0, PPFD=1000.0)]\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_mtg_models!","page":"API","title":"PlantSimEngine.init_mtg_models!","text":"init_mtg_models!(\n    mtg::MultiScaleTreeGraph.Node,\n    models::Dict{String,<:ModelList},\n    i=nothing;\n    verbose=true,\n    attr_name=:models\n)\n\ninitialize the components of an MTG (i.e. nodes) with the corresponding models.\n\nThe function checks if the models associated to each component of the MTG are fully initialized, and if not, tries to initialize the variables using the MTG attributes with the exact same name, and if not found, returns an error.\n\nArguments\n\nmtg::MultiScaleTreeGraph.Node: the MTG tree.\nmodels::Dict{String,ModelList}: a dictionary of models named by components names\ni=nothing: the time-step to initialize. If nothing, initialize all the time-steps.\nverbose = true: return information during the processes\nattr_name = :models: the node attribute name used to store the models\n\nExamples\n\nusing PlantBiophysics, MultiScaleTreeGraph, PlantGeom\n\n# Read the file\nfile = joinpath(dirname(dirname(pathof(PlantBiophysics))),\"test\",\"inputs\",\"scene\",\"opf\",\"coffee.opf\")\nmtg = read_opf(file)\n\n# Declare our models:\nmodels = Dict(\n    \"Leaf\" =>\n        ModelList(\n            energy_balance = Monteith(),\n            photosynthesis = Fvcb(),\n            stomatal_conductance = Medlyn(0.03, 12.0),\n            status = (d = 0.03,)\n        )\n)\n\n# Checking which variables are needed for our models:\n[component => to_initialize(model) for (component, model) in models]\n# OK we need to initialize Rₛ, sky_fraction and the PPFD\n\n# We can compute them directly inside the MTG from available variables:\ntransform!(\n    mtg,\n    [:Ra_PAR_f, :Ra_NIR_f] => ((x, y) -> x + y) => :Rₛ,\n    :Ra_PAR_f => (x -> x * 4.57) => :PPFD,\n    ignore_nothing = true\n)\n\n# Initialising all components with their corresponding models and initialisations:\ninit_mtg_models!(mtg, models)\n# Note that this is possible only because the initialisation values are found in the MTG.\n# If the initialisations are constant values between components, we can directly initialize\n# them in the models definition (we initialize `:d` like this in our example).\n\n\n\n\n\n","category":"function"},{"location":"API/#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nIntialise model variables for components with user input.\n\nExamples\n\nmodel = read_model(\"a-model-file.yml\")\ninit_status!(model, Tₗ = 25.0, PPFD = 1000.0, Cₛ = 400.0, Dₗ = 1.2)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nIntialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\ninit_variables(Monteith())\ninit_variables(energy_balance = Monteith(), stomatal_conductance = Medlyn(0.03,12.0))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\ninit_variables_manual(status, (Tₗ = 20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nleaf = ModelList(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0))\nis_initialized(leaf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.pre_allocate_attr!-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.pre_allocate_attr!","text":"pre_allocate_attr!(node, nsteps; attr_name = :models)\n\nPre-allocate the node attributes based on the status of a component model and a given number of simulation steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.pull_status!-Tuple{Any}","page":"API","title":"PlantSimEngine.pull_status!","text":"pull_status!(node)\n\nCopy the status of a node's component models (e.g. the outputs of a [ModelList]@ref simulation) into the MTG attributes. This function is used when we need to compute further the simulation outputs with e.g. transform!.\n\nNotes\n\nCarefull, this function makes a copy, so the values are then present at two locations (can take a lot of memory space if using several plants).\n\nExamples\n\nusing PlantBiophysics\n\n# Read the file\nmtg = read_mtg(joinpath(dirname(dirname(pathof(PlantBiophysics))),\"test\",\"inputs\",\"scene\",\"opf\",\"coffee.opf\"))\n\n# Declare our models:\nmodels = Dict(\n    \"Leaf\" =>\n        ModelList(\n            energy_balance = Monteith(),\n            photosynthesis = Fvcb(),\n            stomatal_conductance = Medlyn(0.03, 12.0),\n            status = (d = 0.03,)\n        )\n)\n\ntransform!(\n    mtg,\n    [:Ra_PAR_f, :Ra_NIR_f] => ((x, y) -> x + y) => :Rₛ,\n    :Ra_PAR_f => (x -> x * 4.57) => :PPFD,\n    ignore_nothing = true\n)\n\n# Initialising all components with their corresponding models and initialisations:\ninit_mtg_models!(mtg, models)\n\n# Make a simulation\ntransform!(mtg, :models => (x -> energy_balance!(x, meteo)), ignore_nothing = true)\n# Pull the simulation results into the MTG attributes:\ntransform!(mtg, pull_status!)\n# Now the simulated variables are available from the MTG attributes field:\nnames(mtg)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.pull_status_one_step!-Tuple{Any, Any}","page":"API","title":"PlantSimEngine.pull_status_one_step!","text":"pull_status_one_step!(node, step; attr_name = :models)\n\nCopy the status of a node's ModelList (i.e. the outputs of the simulations) into the pre-allocated MTG attributes, i.e. one value per step.\n\nSee pre_allocate_attr! for the pre-allocation step.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.status-Tuple{Any}","page":"API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"API","title":"PlantSimEngine.to_initialize","text":"to_initialize(v::T, vars...) where T <: Union{Missing,AbstractModel}\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyTree)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nExamples\n\nto_initialize(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0))\n\n# Or using a component directly:\nleaf = ModelList(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0))\nto_initialize(leaf)\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}","page":"API","title":"PlantSimEngine.update_mtg_models!","text":"update_mtg_models!(mtg::MultiScaleTreeGraph.Node, i, attr_name::Symbol)\n\nUpdate the mtg models initialisations by using the ith time-step. The mtg is considered fully initialized already once, so init_mtg_models! must be called before update_mtg_models!.\n\nThe values are updated only for node attributes in to_init. Those attributes must have several time-steps, i.e. indexable by 1:n time-steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Tuple{}","page":"API","title":"PlantSimEngine.variables","text":"variables()\n\nReturns a dataframe of all variables in PlantBiophysics, their description and their units.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\nExamples\n\nvariables(Monteith())\n\nvariables(Monteith(), Medlyn(0.03,12.0))\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nvariables_typed(Monteith())\n\nvariables_typed(Monteith(), Medlyn(0.03,12.0))\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"API/#PlantSimEngine.@gen_process_methods-Tuple{Any}","page":"API","title":"PlantSimEngine.@gen_process_methods","text":"@gen_process_methods(process::String)\n\nThis macro generate the abstract type and standard functions for a process, along with  their documentation.\n\nIt generates the three following functions (replace process by your own process name):\n\nprocess: a non mutating function that makes a copy of the object\nprocess!: a mutating function that updates the object status\nprocess!_: the actual workhorse function that does the computation, and is called by the \n\ntwo previous functions under the hood. Modelers implement their own method for this function  for their own model types.\n\nThe two first functions have several methods:\n\nThe base method that runs over one time-step and one object.\nThe method applying the computation over several objects (e.g. all leaves of a plant)\n\nin an Array\n\nThe same method over a Dict(-alike) of objects\nThe method that applies the computation over several meteo time steps and\n\npossibly several objects\n\nA method for calling the process without any meteo (e.g. for fitting)\nA method to apply the above over MTG nodes (see details)\n\nExamples\n\n@gen_process_methods \"dummy_process\"\n\n\n\n\n\n","category":"macro"}]
}
